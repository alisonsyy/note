[TOC]


# [**:house:**](../../README.html)

## 一、JVM的体系结构
![](./images/JVM.png)

### 1.1 类加载器
>负责加载.class文件，将class文件字节码内容加载到内存中，并将这些内容转换为方法区中的运行时数据结构。
#### 类加载器的流程

从类被加载到虚拟机内存开始，到释放内存一共有7个步骤：加载，验证，准备，解析，初始化，使用，卸载。
1. **加载**：**查找并加载类的二进制数据(class文件)**；**方法区：类的类信息。堆：class文件对应的类实例。**
- 通过一个类的全限定名来获取定义此类的二进制字节流；
- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；
- 在堆中生成一个代表这个类的java.lang.Class对象作为方法区这个类的各种数据访问的入口；
2. **连接**
- **验证**:  **确保加载的类符合JVM规范和安全**，保证被校验类的方法在运行时不会做出危害虚拟机的事件；

- **准备**：**为static变量在方法区中分配内存空间，设置变量初始值**；

  > - static变量分配空间和赋值是两个步骤，分配空间在准备阶段完成，赋值在初始化阶段完成。
  > - 如果static变量是final基本类型以及字符串常量，那么编译阶段值就确定了，赋值在准备阶段完成。
  > - 如果static变量是final的,但属于引用类型，那么赋值也会在初始化阶段完成

- **解析**: **虚拟机将常量池内的符号引用替换为直接引用的过程**（符号引用比如我现在import java.util.ArrayList这就算符号引用，直接引用就是指针或者对象地址，注意引用对象一定是在内存进行）。其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定

  > 符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可。
  >
  > 直接引用：直接引用是可以直接指向目标的指针，相对偏移量或者是一个能间接定位到目标的句柄。
3. **初始化**：**JVM对类进行初始化，对静态变量赋予正确值。**初始化其实就是执行类构造器方法的<clinit>()的过程，而且要保证执行前父类的<clinit>()方法执行完毕。这个方法由编译器收集，顺序执行所有类变量（static修饰的成员变量）显式初始化和静态代码块中语句。此时准备阶段时的那个 static int a 由默认初始化的0变成了显式初始化的3. 由于执行顺序缘故，初始化阶段类变量如果在静态代码块中又进行了更改，会覆盖类变量的显式初始化，最终值会为静态代码块中的赋值。

   > **类的初始化是懒惰的**，以下情况会初始化
   >
   > - main 方法所在的类，总会被首先初始化
   > - 首次访问这个类的静态变量或静态方法时
   > - 子类初始化，如果父类还没初始化，会引发
   > - 子类访问父类的静态变量，只会触发父类的初始化
   > - Class.forName
   > - new 会导致初始化
   >
   > 以下情况不会初始化
   >
   > - 访问类的 static ﬁnal 静态常量（基本类型和字符串）
   > - 类对象.class 不会触发初始化
   > - 创建该类对象的数组
   > - 类加载器的.loadClass方法
   > - Class.forNamed的参数2为false时
   >
   > **验证类是否被初始化，可以看改类的静态代码块是否被执**
3. **卸载**：**GC将无用对象从内存中卸除**。
#### 双亲委派机制
- **当一个类收到了加载请求时，它不会先自己去尝试加载，而是委派给父类完成。** 比如我现在要new一个Person，这个Person是我们自定义的类，如果我们要加载它，就会先委派AppClassLoader，只有当父类加载器都反馈自己无法完成这个请求（也就是父类加载器都没有找到加载所需的Class）时，子类加载器才会自行尝试加载。

- 这样做的好处就是保证使用不同的类加载器得到的都是同一个结果。

  > 使用双亲委派模型来组织类加载器之间的关系，一个显而易见的好处就是java中的类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，他是存放在rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都能保证是同一个类。

<img src="./images/类加载器.png" style="zoom:50%;" />

#### 怎么打破双亲委派模型？

> https://blog.csdn.net/weixin_37990128/article/details/110086851?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&spm=1001.2101.3001.4242

1. **重写loadClass()方法破坏双亲委派模型**

   loadClass的作用是通过指定的全限定类名加载class。这里最主要的是重写loadClass()方法，因为双亲委派机制的实现都是通过这个方法实现的，这个方法可以指定类通过什么加载器来进行加载，所以如果改写了它的加载规则，就相当于打破了双亲委派机制。默认过程是这样的，先判断这个类是不是已经被当前层的类加载过了，如果没有加载过就将该类委派给父类加载器，如果父加载器无法加载再向下传递，回来由自己加载。**重写了这个方法以后就能自己定义使用什么加载器了，也可以自定义加载委派机制，也就打破了双亲委派模型。**

2. **线程上下文类加载器破坏双亲委派模型**

   

### 1.2 运行时数据区

<img src="./images/JVM运行时数据区域.png" style="zoom:67%;" />

<img src="./images/Java运行时数据区域JDK1.8.png" style="zoom: 67%;" />



**线程私有的**:

- 程序计数器
- 虚拟机栈
- 本地方法栈

**线程共享的**：

- 堆
- 方法区
- 直接内存

#### 程序计数器
- 字节码解释器通过改变程序计数器来依次读取指令，从而**实现代码的流程控制**，如:顺序执行，选择，循环，异常处理。
- 在多线程的情况下，程序计数器用于**记录当前线程的执行位置**，从而当线程被切换回来的时候能够直到该线程上次运行到哪了。
- 如果线程正在执行的是一个`java`方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址，如果正在执行的是本地方法，这个计数器则应该为空。
- 此内存区域是唯一一个没有规定任何`OutOfMemoryError`情况的区域。
#### 虚拟机栈
- **每个线程运行所需要的内存，称为虚拟机栈。**

- **java虚拟机栈是由一个个栈帧组成，对应着每次方法调用时所占的内存。每个栈帧都有：局部变量表，操作数栈，动态链接，方法出口等信息。**

- **局部变量表**主要存放了编译期可知的各种`Java`虚拟机的各种基本数据类型(boolean,byte,char,short,int float,long,double)，对象引用(reference类型，它并不等同于对象本身，可能时一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者与此对象相关的位置)和`returnAddress`类型(指向了一条字节码指令的地址)。

- **两类异常**：如果线程请求的栈深度大于虚拟机所允许的深度，将会抛出`StackOverflowError`异常；如果`java`虚拟机栈容量可以动态扩展(HotSpot不能扩展)，当栈扩展时无法申请到足够的内存会抛出`OutOfMemoryError`异常。

  > - 当每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧，每个方法被调用直至执行完毕的过程，就对应着一个栈帧再虚拟机从入栈到出栈的过程。
  > - 基本数据类型包括 boolean, byte,char,short,int,float,double,long.
  > - 对象引用：reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能使指向一个代表对象的句柄或者其他与此对象相关的位置。
  > - `returnAddress`类型：指向了一条字节码指令的地址。
  > - 垃圾回收不涉及栈内存，栈内存在每次方法调用完毕出栈之后就自动被回收了。
  > - 线程安全问题
  >   - 如果方法内局部变量没有逃离方法的作用范围，它是线程安全的。、
  >   - 如果局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全问题。
  > - 栈内存溢出
  >
  >   - 栈帧过多造成栈内存溢出
  >   - 单个栈帧过大造成栈内存溢出(不太容易出现)
#### 本地方法栈
- **本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。**
-  虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。 
#### 堆
- **用于存放对象实例，几乎所有的对象实例以及数组都在这里分配。**
- 在JDK7版本以及以前的版本，堆内存分为三部分：**新生代(Eden 空间、From Survivor、To Survivor )**，**老生代**，**永久代。**
- 在JDK8之后方法区(HotSpot的永久代被彻底移除了)，取而代之的是元空间，元空间使用的是直接内存。
>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区->Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。
>
>- 堆内存溢出问题
>  - **java.lang.OutofMemoryError** ：java heap space. 堆内存溢出
>- Java 世界中“几乎”所有的对象都在堆中分配，但是，随着 JIT 编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从 JDK 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。
#### 方法区
- **它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。**
- 可以选择不实现垃圾回收，回收目标主要时针对常量池的回收和对类型的卸载。

<img src="./images/方法区.png" style="zoom: 50%;" />

##### 运行时常量池
- **是方法区的一部分**

- **Class 文件中的常量池表（编译器生成的字面量和符号引用）会在类加载后被放入这个区域，**并把里面的符号地址变成真实地址。

  > Class文件中除了由类的版本，字段，方法，接口等描述信息外，还有一项时常量池表，虚拟机指令根据这张常量表找到要执行的类名，方法名，参数类型，字面量(字符串，整数，布尔类型等)等信息。

##### 无用的类？

方法区主要回收的是无用的类，。类需要同时满足下面 3 个条件才能算是 **“无用的类”** ：

- 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
- 加载该类的 `ClassLoader` 已经被回收。
- 该类对应的 `java.lang.Class` 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。

##### 废弃的常量

假如在字符串常量池中存在字符串 "abc"，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 "abc" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，"abc" 就会被系统清理出常量池了。

#### 直接内存

- 直接内存并不是虚拟机运行时数据区的一部分，而是属于操作系统内存。
- 在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据。
- 属于操作系统，常见于NIO操作时，**用于数据缓冲区**
- 分配回收成本较高，但读写性能高
- 不受JVM内存回收管理

**不使用直接内存**

<img src="./images/文件读写流程.png" style="zoom: 50%;" />

**使用直接内存**

<img src=".\images\使用直接内存.png" style="zoom: 50%;" />

直接内存是操作系统和Java代码**都可以访问的一块区域**，无需将代码从系统内存复制到Java堆内存，从而提高了效率.

### 1.3 执行引擎

用来执行方法区中的字节码指令

### 1.4 代码演示

```java
public class TestFrame{//1
    
    public static void main(String []args){   //2     
        method1(10);//3
    }
    private static void method1(int x){//4
        
        int y = x + 1;//5
        Object m = method2();//6
        System.out.println(m);//7
    }
    private static Object method2(){//8
        
        Object n = new Object();//9
        return n;//10
    }
}
```

- 第一行，java虚拟机会先进行类加载，将类中的字节码加到java的虚拟机中，也就是方法区。
- 类加载完，java虚拟机就会启动一个为main的主线程，并且为这个线程分配一个栈内存，然后线程就交给任务调度器去执行。当cpu为主线程分配了时间片，cpu就开始运行主线程，运行到哪行代码由程序计数器来记录。

<img src="./images/代码1.png" style="zoom: 50%;" />

- 第二行：入口是main方法，则虚拟机会为main方法创建一个栈帧。

<img src="./images/代码2.png" style="zoom: 50%;" />

- 第三行：进入method1方法，也会为method1方法创建一个栈帧。x=10写进栈帧。

<img src="./images/代码3.png" style="zoom: 50%;" />

- 第五行：执行完后y = 11;
- 第六行：进入method2方法，同时为method2方法创建一个栈帧。

<img src="./images/代码4.png" style="zoom: 50%;" />

- 第九行：在堆中新建一个对象，并将对象的引用n指向对象。

  <img src="./images/代码5.png" style="zoom: 50%;" />

- 第10行：返回n,并将m指向object对象。

<img src="./images/代码6.png" style="zoom:60%;" />

- 之后释放method2的栈帧内存。返回到method1,之后method1执行完，其栈帧也要释放掉。

## 二、HotSpot虚拟机

#### 2.1 对象创建的过程

1. **类加载检查**（先判断有没有加载过）

   虚拟机遇到一个new指令，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已经被加载过，解析和初始化过，如果没有，那必须先执行响应的类加载过程。

2. **分配内存**（没有加载过就为对象在堆中分配内存）

   **在类加载检查通过后，接下来虚拟机将会为新生对象分配内存。对象所需的内存大小在类加载完成后便可确认**，为对象分配空间的任务等同于把一块确定大小的内存从java堆中划分出来。分类方式有指针碰撞和空闲列表方式，选择哪种分配方式是由java堆是否规整决定的，而java堆是否规整又有采用的垃圾收集器是否带有压缩整理功能决定。

   > **HotSpot虚拟机内存分配的两种方式**
   >
   > 1. 指针碰撞
   >
   > - 适用场合:堆内存规整(即没有内存碎片);
   > - 用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界值指针，只需要向着没有用过的内存方向将该指针移动对象内存大小位置即可。
   > - GC收集器：Serial,ParNew
   >
   > 2. 空闲列表
   >
   > - 适合用于堆内存不规整的情况;
   >
   > - 虚拟机会维护一个列表，该列表会记录哪些内存块是可用的，在分配的时候，找一块足够大的内存块来分配给对象实例，最后更新列表记录.
   >
   > - GC收集器：CMS
   >
   >   **HotSpot虚拟机内存分配的并发问题**
   >
   >   - **CAS+失败重试：** CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。
   >   - **线程本地分配缓存区(TLAB)**: 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配
   >
   >   ****

3. **初始化零值**

   内存分配完后，虚拟机需要将分配到的内存空间都初始化为零值(不包括对象头)，这一步操作**保证了对象实例字段在java代码中可以不赋初始值就可以使用**，程序能访问到这些字段的数据类型所对应的零值。

4. **设置对象头**

   初始化零值后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例，如果才能找到类的元数据信息，对象的哈希码，对象的GC分代年龄等信息。这些信息存放在对象头中。另外根据虚拟机当前运行状态的不同，如是否用偏向锁等，对象头会有不同的设置方式。

5. **执行<init>方法**

   new指令之后会接着执行<init>方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才完全被构造出来。

   > 在上面工作都完成之后，从虚拟机的视角，一个对象已经产生了，但是从java程序视角来看，构造函数，即class文件中的<init>方法还没有执行，所有的字段都为默认的零值，对象需要的其他资源和状态信息也还没有按照预定的意图构造好。

#### 2.2 对象的内存布局

在hotSpot虚拟机中，对象在内存中的布局可以分为3块区域：对象头，实例数据和对齐填充。

- **对象头**：包含两部分信息，第一部分用于**存储对象自身的运行时数据**（哈希码，GC分代年龄，锁状态标志等），另一部分是**类型指针**，即对象指向它的类型元数据的指针，java虚拟机通过这个指针来确定该对象是哪个类的实例。
- **实例数据**：是对象真正存储的有效信息，也是在**程序中所定义的各种类型的字段内容**。
- **对齐填充**：**没有特别的含义，只起占位作用。**因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。

#### 2.3 对象的访问定位

- `java`程序通过栈上的reference数据来操作堆上的具体对象，对象的访问方式由虚拟机实现而定，目前主流的访问方式由**使用句柄**和**直接指针**两种。

- 这两种对象访问方式各有优势，使用句柄来访问的最大好处是**reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要修改**。使用**直接指针访问的最大好处就是速度快，它节省了一次指针定位的时间开销。**

1. **句柄**： 如果使用句柄的化，java堆中会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据域类型数据各自的具体地址信息。

   <img src=".\images\对象的访问定位-使用句柄.png" style="zoom:50%;" />

2. **直接指针**：如果使用直接指针访问，那么java堆对象的布局就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象的地址。

<img src=".\images\对象的访问定位-直接指针.png" style="zoom:50%;" />

## 三、垃圾回收器(GC)
#### 3.1 如何判断对象已经死亡？
1. **引用计数法**
- 给对象添加一个引用计数器，每当有一个地方引用他，计数器就加1，当引用失效，计数器就间1，当计数器为0时对象就是不可用的了。
- 这个方法实现简单，效率高，但是很难解决对象之间相互循环引用的问题。
2. **可达性分析算法**
- 基本思想就是通过一系列的"GC Roots"的对象作为起点，从这个节点开始向下搜索，节点所走过的路径称为引用链，当一个对象GC Roots没有任何引用链相连的话，则证明对象是不可用的。
- GCRoot
  - 虚拟机栈（栈帧中的本地变量表）中引用的对象。
  - 方法区中类静态属性引用的对象
  - 方法区中常量引用的对象
  - 本地方法栈中JNI（即一般说的Native方法）引用的对象

3. **方法区的回收**

   因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。

   **主要是对常量池的回收和对类的卸载。**

   为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。

   类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载：

   - **该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。**
   - **加载该类的 ClassLoader 已经被回收。**
   - **该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法**

#### 3.2 引用的类型

> 引用本身也是一种对象
>
> 软引用：List<SoftReference<byte[]>> list=new ArrayLIst<>();
>
> ​               SoftReference<byte[]>  ref = new SoftReference<>(new byte[1024])
>
> ​                list.add(ref);
>
> 在这里list 强引用SoftReference对象，然后通过SoftReference间接引用byte数组。

<img src="./images/五种引用.png" style="zoom:50%;" />

1. **强引用**：**对于强引用，垃圾回收器绝对不会回收它(即使内存不足)。只有GC Root都不引用该对象时，才会回收强引用对象。**

2. **软引用**：**当GC Root指向软引用对象时，在内存不足时，会回收软引用所引用的对象。**但是软引用本身不会被清理。如果想要清理软引用，需要使用引用队列。大概思路为：查看引用队列中有无软引用，如果有，则将该软引用从存放它的集合中移除（这里为一个list集合。图片缓存框架中，“内存缓存”中的图片是以这种引用保存，使得 JVM 在发生 OOM 之前，可以回收这部分缓存。

   ```java
   //软引用
   public class Demo1 {
   	public static void main(String[] args) {
   		final int _4M = 4*1024*1024;
   		//使用软引用对象 list强引用SoftReference，而SoftReference和byte数组则是软引用
   		List<SoftReference<byte[]>> list = new ArrayList<>();
   		SoftReference<byte[]> ref= new SoftReference<>(new byte[_4M]);
   	}
   }
   //清理软引用需要使用引用队列
   public class Demo1 {
   	public static void main(String[] args) {
   		final int _4M = 4*1024*1024;
   		//使用引用队列，用于移除引用为空的软引用对象
   		ReferenceQueue<byte[]> queue = new ReferenceQueue<>();
   		//使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用
   		List<SoftReference<byte[]>> list = new ArrayList<>();
   		SoftReference<byte[]> ref= new SoftReference<>(new byte[_4M]);
   
   		//遍历引用队列，如果有元素，则移除
   		Reference<? extends byte[]> poll = queue.poll();
   		while(poll != null) {
   			//引用队列不为空，则从集合中移除该元素
   			list.remove(poll);
   			//移动到引用队列中的下一个元素
   			poll = queue.poll();
   		}
   	}
   }
   ```

3. **弱引用**：只有弱引用引用该对象时，**在垃圾回收时，无论内存是否充足，都会回收弱引用所引用的对象。**如上图如果B对象不再引用A3对象，则A3对象会被回收。弱引用的使用和软引用类似，只是将 SoftReference 换为了 WeakReference。

4. **虚引用**：**如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。**当虚引用对象所引用的对象被回收以后，虚引用对象就会被放入引用队列中。

   - 虚引用的一个体现是**释放直接内存所分配的内存**，当引用的对象ByteBuffer被垃圾回收以后，虚引用对象Cleaner就会被放入引用队列中，然后调用Cleaner的clean方法来释放直接内存。
   - 如上图，B对象不再引用ByteBuffer对象，ByteBuffer就会被回收。但是直接内存中的内存还未被回收。这时需要将虚引用对象Cleaner放入引用队列中，然后调用它的clean方法来释放直接内存

5. ##### 终结器引用：所有的类都继承自Object类，Object类有一个finalize方法。当某个对象不再被其他的对象所引用时，会先将终结器引用对象放入引用队列中，然后根据终结器引用对象找到它所引用的对象，然后调用该对象的finalize方法。调用以后，该对象就可以被垃圾回收了。

   - 如上图，B对象不再引用A4对象。这是终结器对象就会被放入引用队列中，引用队列会根据它，找到它所引用的对象。然后调用被引用对象的finalize方法。调用以后，该对象就可以被垃圾回收了。

**引用队列**

- 软引用和弱引用**可以配合**引用队列：在**弱引用**和**虚引用**所引用的对象被回收以后，会将这些引用放入引用队列中，方便一起回收这些软/弱引用对象。
- 虚引用和终结器引用**必须配合**引用队列：虚引用和终结器引用在使用时会关联一个引用队列。

#### 3.3 垃圾回收算法
1. **标记清除算法：** 在**标记阶段**，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记。在**清除阶段**，会进行对象回收并取消标志位，另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块。回收对象就是把对象作为分块，连接到被称为 “空闲链表” 的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。
- **优点:** 对象不需要移动，只操作不存活对象，存活对象多的时候不影响效率。
- **缺点：** **执行效率不稳定**，执行效率随着对象数量的增长而降低。**空间问题**，标记清除后会产生大量的不连续的碎片。
- **适合:** 存活比例高的，希望暂停时间尽可能短的。
2. **标记复制算法**：将内存分为大小相同的两块，每次使用其中的一块，当这一块的内存使用完后，就将还存活的对象复制到另外一块去，然后把使用的空间一次清理掉。
- **优点：** 无碎片，标记和复制可以同时进行，每次只对一块内存进行回收，高效，实现简单。
- **缺点：** 额外空间，空间利用率低；需要暂停。
- **适合：** 存活比例少，回收不频繁，内存申请次数多
3. **标记整理算法**: 让存活的对象向一端移动，直接清理掉端边界以外的内存。
- **优点：** 无碎片，内存分配更加快速，空闲大小和位置便于统计。
- **缺点：** 因为要移动存活的变量，和重新引用赋值， 就需要执行暂停，使得GC时间延长。
- **适合：** 存活比例高，回收不频繁
4. **分代收集算法**
- 对于新生代，可以选择标记复制.
- 对于老年代，可以选择标记清除或者标记整理。
- 流程：
  - 新创建的对象都被放在了**新生代的伊甸园**中。
  - 当伊甸园中的内存不足时，就会进行一次垃圾回收，这时的回收叫做 **Minor GC**（会触发 **stop the world**， 暂停其他用户线程，只让垃圾回收线程工作）。
  - Minor GC 会将**伊甸园和幸存区FROM**存活的对象**先**复制到 **幸存区 TO**中， 并让其**寿命加1**，再**交换两个幸存区**。
  - 再次创建对象，若新生代的伊甸园又满了，则会**再次触发 Minor GC**，这时不仅会回收伊甸园中的垃圾，**还会回收幸存区中的垃圾**，再将活跃对象复制到幸存区TO中。回收以后会交换两个幸存区，并让幸存区中的对象**寿命加1**。(也就是保证To区是空的。)
  - 如果幸存区中的对象的**寿命超过某个阈值**（最大为15，4bit），就会被**放入老年代**中。
  - 如果新生代老年代中的内存都满了，就会先触发Minor GC，如果之后内存还是不足。再触发**Full GC**，扫描**新生代和老年代中**所有不再使用的对象并回收。

#### 3.4 [常见的垃圾回收器](https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6?id=_41-serial-%e6%94%b6%e9%9b%86%e5%99%a8)

- **并行收集**：指多条垃圾收集线程并行工作，但此时**用户线程仍处于等待状态**。
- **并发收集**：指用户线程与垃圾收集线程**同时工作**（不一定是并行的可能会交替执行）。**用户程序在继续运行**，而垃圾收集程序运行在另一个CPU上。
- **吞吐量**：即CPU用于**运行用户代码的时间**与CPU**总消耗时间**的比值（吞吐量 = 运行用户代码时间 / ( 运行用户代码时间 + 垃圾收集时间 )），也就是。例如：虚拟机共运行100分钟，垃圾收集器花掉1分钟，那么吞吐量就是99%
- **串行**
  - 单线程
  - 内存较小，个人电脑（CPU核数较少）
- 吞吐量优先：
  - 多线程
  - 堆内存较大，多核cpu
  - 让单位时间内STW时间短   单次0.2秒，比0.1s多，但是总共花的时间少一共0.2s
- 响应时间优先：
  - 多线程
  - 堆内存较大, 多核cpu
  - 尽可能让单次STW的时间最短   单次0.1s ，有三次  也就是一共0.3s

![](./images/垃圾收集器.jpg)

##### 3.4.1 Serial收集器

![](./images/serial.jpg)

**Serial（串行）收集器是一个单线程收集器了。它只会使用一条垃圾收集线程去完成垃圾收集工作，在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ "Stop The World" ），直到它收集结束。**

- 收集算法：**新生代采用标记-复制算法，老年代采用标记-整理算法。**
- 缺点：进行垃圾收集工作的时候必须暂停其他所有的工作线程。
- 优点：简单而高效（与其他收集器的单线程相比）。Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。

##### 3.4.2 SerialOld收集器

**是 Serial 收集器的老年代版本**，也是给 Client 场景下的虚拟机使用。如果用在 Server 场景下，它有两大用途：

- 在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。
- 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。

##### 3.4.3 Parallel Scavenge 收集器 

**Parallel Scavenge 收集器也是使用标记-复制算法的多线程收集器。**

```java
-XX:+UseParallelGC

    使用 Parallel 收集器+ 老年代串行

-XX:+UseParallelOldGC

    使用 Parallel 收集器+ 老年代并行

```

- **Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。** Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成也是一个不错的选择。
- **新生代采用标记-复制算法，老年代采用标记-整理算法。**
- JDK1.8 默认使用的是 Parallel Scavenge + Parallel Old，如果指定了-XX:+UseParallelGC 参数，则默认指定了-XX:+UseParallelOldGC，可以使用-XX:-UseParallelOldGC 来禁用该功能

##### 3.4.4 Parallel Old 收集器

**Parallel Scavenge 收集器的老年代版本**。使用**多线程和“标记-整理”算法**。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。

##### 3.4.5 ParNew收集器

**ParNew 收集器其实就是 Serial 收集器的多线程版本，也就是GC线程并发，应用程序暂停。** 除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。

- 收集算法：**新生代采用标记-复制算法，老年代采用标记-整理算法。**
- 它是许多运行在 Server 模式下的虚拟机的首要选择，**除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。**

##### 3.4.6 CMS 收集器

<img src="./images/CMS收集器.png" style="zoom:67%;" />

- **CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。**
- **CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。**
- CMS 收集器是一种 **“标记-清除”算法**实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：
  - **初始标记：** 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；
  - **并发标记：** 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
  - **重新标记：** 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短
  - **并发清除：** 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。
- 从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：**并发收集、低停顿**。但是它有下面三个明显的缺点：
  - **对 CPU 资源敏感；**
  - **无法处理浮动垃圾**：并发清除过程中用户线程产生的垃圾。
  - **它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。**
- 与ParNew收集器配合使用，因为使用标记清除，所以有可能会造成空间碎片，碎片过多造成并发失败，会退化到 Serial收集器。

##### 3.4.7 G1收集器

Garbage First

- JDK 9以后默认使用，而且替代了CMS 收集器

- ##### 适用场景

  - 同时注重吞吐量和低延迟（响应时间）
  - 超大堆内存（内存大的），会将堆内存划分为多个**大小相等**的区域
  - 整体上是**标记-整理**算法，两个区域之间是**复制**算法

![](./images/G1.png)

- 回收阶段

  - **初始标记**: 在 Young GC 时会**对 GC Root 进行初始标记**，仅仅发生在新生代回收阶段, 会STW;

  - **并发标记**:在老年代**占用堆内存的比例**达到阈值(45%)时，对进行并发标记，从根对象出发，标记其他对象（不会STW），阈值可以根据用户来进行设定。

  - **最终标记(Remark)**：会STW. 在**并发标记过程中**，有可能会漏掉一些对象，需要重新标记。

  - **拷贝存活**：会STW;并不是所有的老年代都会被拷贝。

    - **问**：为什么有的老年代被拷贝了，有的没拷贝？

      因为指定了最大停顿时间，如果对所有老年代都进行回收，耗时可能过高。为了保证时间不超过设定的停顿时间，会**回收最有价值的老年代**（回收后，能够得到更多内存).

#### 3.5 FullGC 与minorGC

- SerialGC
  - 新生代内存不足垃圾回收 minorGC
  - 老年代内存不足垃圾回收  FullGC 
- ParallelGC
  - 新生代内存不足垃圾回收 minorGC
  - 老年代内存不足垃圾回收  FullGC 
- CMS
  - 新生代内存不足垃圾回收 minorGC
  - 老年代内存不足
    - 并发失败后，会进行Full GC
- G1
  - 新生代内存不足垃圾回收 minorGC
  - 老年代内存不足（老年代所占内存超过阈值）
    - 如果垃圾产生速度慢于垃圾回收速度，不会触发Full GC，还是并发地进行清理
    - 如果垃圾产生速度快于垃圾回收速度，便会触发Full GC

## 四、内存分配策略与回收策略

### 4.1  Minor GC 和 Full GC

- Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。
- Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。

### 4.2 内存分配策略

**1. 对象优先在 Eden 分配**

大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。

**2. 大对象直接进入老年代**

**大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。**

经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。

-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制、

**3. 长期存活的对象进入老年代**

**为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。**

-XX:MaxTenuringThreshold 用来定义年龄的阈值

 **4. 动态对象年龄判定**

虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，**如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代**，无需等到 MaxTenuringThreshold 中要求的年龄。

**5. 空间分配担保**

**在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。**

如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。

### 4.3 Full GC 的触发条件

对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件：

 **1. 调用 System.gc()**

只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存.

**2. 老年代空间不足**

**老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。**

为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。

 **3. 空间分配担保失败**

**在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。**

如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。

**4. JDK 1.7 及以前的永久代空间不足**

在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。

当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。

为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。

**5. Concurrent Mode Failure**

执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。

## 五、重点知识补充

### 5.1 常量池

java的常量池有三种，即字符串常量池，class常量池，运行时常量池。

1. class常量池：我们写的每一个java类被编译之后都会生成一个对应的class文件。class文件中除了有类的版本，字段方法，接口等描述信息外，还有一项信息时常量池，用于存放编译期生成的各种字面量和符号引用。每个类都有一个class常量池。

   > 什么时字面量和符号引用？
   >
   > 字面量比较接近于java语言层面的常量概念，如文本字符串，声明为final的常量值和8种基本类型的变量，而符号引用则属于编译原理方面的概念，包括三类变量:类和接口的全限定名。字段的名称和描述符。方法的名称和描述符

2. 字符串常量池

   - 为字符串开辟一个字符串常量池，类似于缓存区。
   - 创建字符串常量时，首先检查字符串常量池是否存在该字符串
   - 若存在该字符串，返回引用实例；若不存在，实例化该字符串并放入池中
   - 在JDK1.6之前，字符串常量池在方法区，在JDK1.7，字符串常量池被移入了堆中。移入堆中的原因大概是方法区的内存空间太小了。

3. 运行时常量池

   - 运行时常量池存在于内存中的方法区，class常量池被加载到内存之后会存放在运行时常量池中。除了保存Class文件中描述的符号引用外，还会把符号引用翻译为直接引用，并存储在运行时常量池中。

   

   ![](./images/常量池对比.png)

   

### 5.2 String类与常量池

string类对象创建的两种方式:

```java
String str1='abcd';//先检查字符串常量池中有没有‘abcd’，如果没有，则创建一个，然后str1指向字符串常量池中的对象，如果有，直接将str1指向‘abcd’
String str2=new String("abcd");//堆中创建一个新对象
String str3=new String("abcd");//堆中创建一个新对象
System.out.println(str1==str2);//false
System.out.println(str1==str2);//false
```

这两种不同的创建方法是有差别的。

- 第一种方式是在常量池中拿对象；
- 第二种方式是直接在堆内存空间创建一个新的对象。

![](./images/StringPool.png)

String类的常量池比较特殊，它的主要使用方法有两种：

- 直接使用双引号声明出来的String对象会直接存储在常量池中。
- 如果不是双引号声明的String对象，可以使用String使用的intern方法。`String.intern()`是一个Native方法，它的作用是：如果运行时常量池中已经包含了一个等于String对象内容的字符串，则返回常量池中该字符串的引用；如果没有，JDK1.7之前（不包含1.7）的处理方式是在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用，JDK1.7以及之后的处理方式是在常量池中记录此字符串的引用，并返回该引用。

```java
          String s1 = new String("计算机");
          String s2 = s1.intern();
          String s3 = "计算机";
          System.out.println(s2);//计算机
          System.out.println(s1 == s2);//false，因为一个是堆内存中的 String 对象一个是常量池中的 String 对象，
          System.out.println(s3 == s2);//true，因为两个都是常量池中的 String 对象

```

字符串拼接

- 尽量避免多个字符串拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用StrnigBuilder或者StringBuffer.

```java
String str1="str";
String str2="ing";

String str3="str"+"ing";//常量池中的对象
String str4=str1+str2;//在堆上创建的新的对象
String str5="string";//常量池中的对象
System.out.println(str3 == str4);//false
System.out.println(str3 == str5);//true
System.out.println(str4 == str5);//false
```

![](.\images\字符串拼接常量池.png)

### 5.3 String s1 = new String("abc");这句话创建了几个字符串对象？

将创建一个或者两个字符串。

- 创建一个名为s1的变量(引用)；
- 如果String 池中没有"abc"存在，则在String池中创建一个String类型的"abc"，有就不创建；
- 使用new关键字在堆中创建一个String对象
- 将new创建的string对象的地址赋给s1

