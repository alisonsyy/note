[TOC]



# [**:house:**](../../README.html)

# 操作系统基础
## 什么是操作系统？
1. **操作系统本质上是一个运行在计算机上的软件程序，用于管理计算机硬件和软件资源。是计算机的基石。** 举例：运行在电脑上的所有应用程序都是通过操作系统来调用系统内存以及磁盘等硬件。
2. **操作系统的存在屏蔽了硬件层的复杂性。** 操作系统就像硬件使用的负责人，统筹着各种相关事项。
3. **操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。** 内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。

![内核](./images/Kernel_Layout.png)

## 什么是系统调用？
根据进程访问资源的特点，可以把进程在系统上的运行分为两个级别：

1.**用户态** ：当进程在执行用户自己的代码时，则称为其处于用户态，这时候CPU访问资源有限，运行在用户态的程序不能直接访问操作系统的内核数据结构和程序。
2.**系统态（内核态）:**  系统态运行的进程或者程序几乎可以访问计算机的任何资源，不受限制。

**一般运行的程序基本都是在用户态，当需要调用操作系统系统态级别的子功能时，就需要系统调用。** 也就是说在我们运行的用户程序中，凡是系统态级别的资源有关的操作（如文件管理，进程管理，内存管理等），都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。

系统调用按功能可以分为以下几类：
- **设备管理。** 完成设备的请求或者释放，以及设备启动等功能。
- **文件管理。** 完成文件的读，写，创建及删除等功能。
- **进程管理。** 完成进程的创建，撤销，阻塞及唤醒等功能。
- **进程通信。** 完成进程之间的消息传递或者信号传递等功能。
- **内存管理。** 完成内存的分配，回收，以及获取作业占用内存区大小及地址等功能。

# 进程和线程
>https://mp.weixin.qq.com/s/YXl6WZVzRKCfxzerJWyfrg
### 进程和线程的区别

- 进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位；
- 进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈；
- 线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系；
- 线程能减少并发执行的时间和空间开销。

> 对于，线程相比进程能减少开销，体现在：
>
> - **线程的创建时间比进程快**，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，而线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们；
> - **线程的终止时间比进程快**，因为线程释放的资源相比进程少很多；
> - **同一个进程内的线程切换比进程切换快**，因为线程具有相同的地址空间（虚拟内存共享），这意味着同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的；
> - **线程之间的数据交互效率高**：由于同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更高了；
>
> 所以，线程比进程不管是时间效率，还是空间效率都要高。

## 进程

我们编写的代码只是存储在硬盘上的静态文件，通过编译后就会生成二进制可执行文件，在我们运行这个可执行文件后，它就会被装载到内存中，接着CPU会执行程序中的每一条指令，那么在这个运行中的程序，就称为进程。

### 进程的状态

进程分为五种状态：

1. **创建状态：** 进程正在被创建，尚未到达就绪状态。
2. **就绪状态：** 进程已经处于准备运行状态，也就是进程已经获取到除了处理器以外的一切所需资源，一旦得到处理器资源（处理器分配的时间片）就可以运行。
3. **运行状态：** 进程正在处理器上运行。
4. **阻塞状态：** 进程正在等待某一件事件而暂停运行如等待某资源为可用或者等待IO操作完成，即使处理器空闲，该进程也不能运行。
5. **结束状态：** 进程正在从系统中消失。可能是进程正常结束或者因为其他原因中断退出运行。

> 另外，还有一个状态叫**挂起状态**，它表示进程没有占有物理内存空间。这跟阻塞状态是不一样，阻塞状态是等待某个事件的返回。
>
> 挂起状态可以分为两种：
>
> - 阻塞挂起状态：进程在外存（硬盘）并等待某个事件的出现；
> - 就绪挂起状态：进程在外存（硬盘），但只要进入内存，即刻立刻运行；

### 进程控制结构

- 在操作系统中，是用***进程控制块**（*process control block，PCB*）数据结构来描述进程的。
- **PCB 是进程存在的唯一标识**，这意味着一个进程的存在，必然会有一个 PCB，如果进程消失了，那么 PCB 也会随之消失。

通常是通过**链表**的方式进行组织，把具有**相同状态的进程链在一起，组成各种队列**。比如：

- 将所有处于就绪状态的进程链在一起，称为**就绪队列**；
- 把所有因等待某事件而处于等待状态的进程链在一起就组成各种**阻塞队列**；
- 另外，对于运行队列在单核 CPU 系统中则只有一个运行指针了，因为单核 CPU 在某个时间，只能运行一个程序。

PCB包含的信息

- **进程描述信息：**进程标识符和用户标识符
- **进程控制和管理信息**：进程当前的状态，进程抢占CPU的优先级
- **资源分配清单**：有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的 I/O 设备信息。
- **CPU相关信息**：CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行。

### 进程上下文切换

一个进程切换到另一个进程运行，称为进程上下文切换。

- **进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。**
- 会把交换的信息保存在进程的 PCB，当要运行另外一个进程的时候，我们需要从这个进程的 PCB 取出上下文，然后恢复到 CPU 中，这使得这个进程可以继续执行。

发生上下文切换的场景

- **进程时间片用完了**：为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，就会被系统挂起，切换到其它正在等待 CPU 的进程运行；
- **进程资源不足（比如内存不足）**：进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行；
- **进程通过sleep函数主动将自己挂起**：当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度；
- **有更高优先级的进程需要执行**：当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行；
- **硬件中断时**：发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序；

### 进程间通信的方式

> **进程间通信的概念**
> 每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷贝到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制就是**进程间通信**。

![进程间通信](./images/进程间通信.png)

进程间通信有7种方式: https://blog.csdn.net/vicoqi/article/details/109487692

 **匿名管道** 

- **用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。** 管道对于管道两端的进程而言，就是一个文件，但是他不属于某种文件系统，只存在于内存中。
- **无格式的字节流数据并且大小受限。** 这就要求管道的读出方和写入方事先约定好数据的格式。
- **通信方式是单向的。** 如果需要双向通信，就要建立两个管道。
- **匿名管道的生命周期随着进程创建而建立，随着进程终止而消失。**

**有名管道**：

- **可以在不相关的进程间通信。** 有名管道的名字存在文件系统中，内容存放在内存中。即使是不相关的进程，只要可以访问该路径就能够彼此通过有名管道相互通信。
- **严格遵守先进先出。**

 **消息队列** 

 - 管道的通信效率低下，因此不适合**进程间频繁的交换数据**，对于这个问题，消息队列的通信模式就可以解决；
 - **消息队列是保存在内核中的消息链表。** 在发送数据时，会分成一个一个独立的数据单元，也就是消息体（数据块），消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型，所以每个消息体都是固定大小的存储块，不像管道是无格式的字节流数据。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。
 - **消息队列的生命周期随内核。** 如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在。
 - **通信不及时。**
 - **不适合比较大数据的传输。** 因为内核中每个消息体都有一个最大的长度限制，同时所有队列所包含的全部消息体的总长度原始有上限的。
 - **存在用户态与内核态之间的数据拷贝开销** 因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另外一个进程读取内核的消息数据时，会发生从内核态拷贝数据到用户态的过程。

**共享内存**

- **克服了消息队列读写过程中存在用户态与内核态之间的数据拷贝开销问题。**
- **多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中堆共享内存中数据的更新。**
- **如果多个进程同时修改同一个共享内存，很容易造成冲突。**

**信号量**

- **信号量是一个计数器，用于实现进程间的同步。**

> 步骤：1. 首先测试控制该资源的信号量。2. 若此信号量的值为正，则进程可以使用该资源。进程将信号量值减1,表示一个资源被使用。3. 若此信号量的值为0，则进程进入休眠状态，直至信号量值大于0，进程被唤醒，从新进入第1步。4. 当进程不再使用由一个信号控制的共享资源时，该信号量值增1，如果有进程正在休眠等待该信号量，则会被唤醒。

**信号**

- **信号是进程间通信机制中唯一的异步通信机制。** 因为可以在任何时候发送信号给某一个进程，而无需知道该进程的状态。

**套接字**

- **不仅可以跨网络与不同主机的进程间通信，还可以在同主机上进程间通信。**
- 根据创建Socket类型的不同，分为三种常见的通信方式：**实现TCP字节流通信，** **实现UDP数据报通信，** **实现本地进程通信。** 

### 为什么需要线程？

- 单进程没有办法并发执行，影响资源的使用效率；

- 多进程进程间通信效率低。

- 维护进程的系统开销较大，如创建进程时，分配资源、建立 PCB；终止进程时，回收资源、撤销 PCB；进程切换时，保存当前进程的状态信息。

**线程是进程当中的一条执行流程。**同一个进程内多个线程之间可以共享代码段、数据段、打开的文件等资源，但每个线程都有独立一套的寄存器和栈，这样可以确保线程的控制流是相对独立的。

### 线程的优缺点

- 一个进程中可以有多条线程，多条线程可以并发执行，提高执行效率。
- 各个线程之间可以共享地址空间和文件等资源。
- 当进程中一个线程崩溃，会导致其所属进程的所有线程崩溃。如，对于游戏的用户设计，则不应该使用多线程的方式，否则一个用户挂了，会影响其他同个进程的线程。

### 线程上下文切换

这还得看线程是不是属于同一个进程：

- 当两个线程不是属于同一个进程，则切换的过程就跟进程上下文切换一样；
- **当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据**；

所以，线程的上下文切换相比进程，开销要小很多。

### 多线程同步

#### 互斥与同步

互斥：当多线程相互竞争操作共享变量时，在执行过程中发生了上下文切换，就有可能得到不确定的结果，这段代码就被称为临界区，为了能够得到正确的结果，需要保证一个线程在临界区执行时，其他线程应该被阻止进入临界区。

同步：就是并发进程/线程在⼀些关键点上可能需要互相等待与互通消息，这种相互制约的等待与互通信息称为进程/线程同步。

#### 互斥和同步的实现

- **互斥量：** 本质是一把锁，在访问公共资源前对互斥量进行加锁，在访问完成后释放互斥量上的锁。比如自旋锁和无等待锁。

- **信号量：** 信号量是操作系统提供的一种协调共享资源访问的办法。通常信号量表示资源的数量，对应的是一个整形变量。另外，还有两个原子操作的系统调用函数来控制信号量的，分别是：

  - P 操作：将 sem 减 1 ，相减后，如果 sem < 0 ，则进程/线程进⼊阻塞等待，否则继续，表明 P 操作可能会阻塞；
  - V 操作：将 sem 加 1 ，相加后，如果 sem <= 0 ，唤醒⼀个等待中的进程/线程，表明 V 操作不 会阻塞；
  - P 操作是⽤在进⼊临界区之前，V 操作是⽤在离开临界区之后，这两个操作是必须成对出现的。

  > 为每类共享资源设置⼀个信号量 s ，其初值为 1 ，表示该临界资源未被占⽤。
  >
  > 此时，任何想进⼊临界区的线程，必先在互斥信号量上执⾏ P 操作，在完成对临界资源的访问后再执⾏ V 操作。由于互斥信号量的初始值为 1，故在第⼀个线程执⾏ P 操作后 s 值变为 0，表示临界资源为空闲，可分配给该线程，使之进⼊临界区。
  >
  > 若此时⼜有第⼆个线程想进⼊临界区，也应先执⾏ P 操作，结果使 s 变为负值，这就意味着临界资源已被 占⽤，因此，第⼆个线程被阻塞。
  >
  > 并且，直到第⼀个线程执⾏ V 操作，释放临界资源⽽恢复 s 值为 0 后，才唤醒第⼆个线程，使之进⼊临界 区，待它完成临界资源的访问后，⼜执⾏ V 操作，使 s 恢复到初始值 1。

- **事件：** 通过通知操作的方式来保持多线程同步。

#### 死锁

发生死锁的条件：

- **互斥条件**：互斥条件是指多个线程不能同时使⽤同⼀个资源。
- **持有并等待条件**：持有并等待条件是指，当线程 A 已经持有了资源 1，⼜想申请资源 2，⽽资源 2 已经被线程 C 持有了，所 以线程 A 就会处于等待状态，但是线程 A 在等待资源 2 的同时并不会释放⾃⼰已经持有的资源 1。
- **不可剥夺条件**：不可剥夺条件是指，当线程已经持有了资源 ，在⾃⼰使⽤完之前不能被其他线程获取，线程 B 如果也想使 ⽤此资源，则只能在线程 A 使⽤完并释放后才能获取。
- **环路等待条件**：环路等待条件指都是，在死锁发⽣的时候，两个线程获取资源的顺序构成了环形链。⽐如，线程 A 已经持有资源 2，⽽想请求资源 1， 线程 B 已经获取了资源 1，⽽想请求资源 2，这就形成 资源请求等待的环形图。

避免死锁：

- **破坏互斥条件**：这个没有办法实现；
- **破坏请求与保持条件**：一次性申请所有资源；
- **破坏不剥夺条件**：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。
- **破坏循环等待条件**：按序申请资源,释放资源则反序释放。

## 互斥锁、自旋锁、读写锁、悲观锁、乐观锁

>解决多线程共同访问资源时，因为资源竞争造成的数据错乱的问题。
>https://mp.weixin.qq.com/s/CqIXHowIDT1kxyBOO0x7TQ

### 互斥锁和自旋锁

- **互斥锁加锁失败之后，线程会释放CPU。** 使用线程切换来应对，当加锁失败的线程再次加锁成功时，会有两次上下文切换的成本，性能损耗较大。
- **自旋锁加锁失败后，会一直忙等待，直到获取到锁。** 在「用户态」完成加锁和解锁操作，不会主动产生线程上下文切换，所以相比互斥锁来说，会快一些，开销也小一些。**适合用于被锁住的代码运行时间很短的场景。**
- **互斥锁和自旋锁都是最基本的锁，** 更高级的锁都会选择其中一个来实现。

### 读写锁

- **写锁是独占锁**，因为任何一个时刻只有一个线程持有写锁。**读锁是共享锁**，因为读锁可以被多个线程同时持有。
- 可以分为**读优先锁**和**写优先锁**以及**公平读写锁**：读优先锁优先服务读线程，写优先锁优先服务写线程。公平读写锁用队列将获取锁的线程排队，按照先入先出的原则加锁。
- **适合用于能明确区分读操作和写操作的场景。** 读写锁在读多写少的场景中能发挥优势。

### 乐观锁与悲观锁

- **悲观锁** 认为多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问资源前需要先加锁。互斥锁，自旋锁和读写锁都属于悲观锁。**适合用于发生冲突概率非常高的情况。**
- **乐观锁** 在访问公共资源时，先不加锁，修改完共享资源时，再验证这段时间内有没有发生冲突，如果没有再修改资源，如果有则放弃本次操作。**适合用于发生冲突概率非常低的情况**。

# 内存管理

> 操作系统的内存管理主要负责**内存的分配与回收**(申请内存，释放内存)，**地址转换**也就是将逻辑地址转换为相应的物理地址等功能也是操作系统内存管理要做的事情。

## 为什么需要虚拟地址？

- 如果直接使用物理地址，用户可以访问任意内存，这样就很容易破坏操作系统。
- 给运行多个程序造成困难，如果第⼀个程序物理内存的某个地址写⼊⼀个新的值，将会擦掉第⼆个程序存放在相同位置上的所有内容，所以同时运⾏两个程序是根本⾏不通的，这两个程序会⽴刻崩溃。
- 程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区。
- 不同进程使用的虚拟地址彼此隔离，互不干扰。

## 虚拟内存地址和物理内存地址

操作系统为每个进程分配独立的一套虚拟内存，每个进程都不能访问物理地址，操作系统会提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来。

- 我们程序所使用的内存地址叫做虚拟内存地址。
- 实际存在硬件里面的空间地址叫物理内存地址。

![内存管理](images/内存管理.png)


## 常见的几种内存管理机制 
[参考链接](https://mp.weixin.qq.com/s/HJB_ATQFNqG82YBCRr97CA)

### 内存分段
- 程序是由若干个逻辑分段组成，如可由代码分段，数据分段，栈段和堆段组成，不同段是由不同的属性，所以可以使用分段的形式将这些段分离开来。
- 虚拟地址是通过段表与物理地址进行映射，解决了程序本身不需要关心具体的物理内存地址的问题。
- 映射过程：
  - 分段机制下的虚拟地址由两部分组成，段选择子（段号和特权等标志位）和段内偏移量。段选择子存放在寄存器中。
  - 段号作为索引可以通过段表将虚拟地址映射为物理地址。段表保存的是这个段的基地址，段的界限和特权等级。
  - 真实物理地址= 段的基地址 + 段内偏移量。
- 两个不足：第一个是**外部内存碎片的问题**，第二个是**内存交换效率低**的问题。
  - 外部内存碎片：比如物理内存连续的四段，后面如果第一段和第三段的被释放掉了，这样就出现了不连续的两段空闲内存，如果现在有一个程序需要加载进来，但是该程序的内存大于第一段和第三段的内存，就造成了新的程序无法进行装载。
  - 解决的办法就是：内存交换，也就是将第二段占用的内存写到硬盘上，然后再从硬盘读会到内存里紧挨第四段的内存。这样新的程序就可以装载进来。
>**外部内存碎片**：也就是产生了多个不连续的小物理内存，导致新的程序无法装载; 解决方法是使用**内存交换**。
>**内部内存碎片**：程序所有的内存都被装在到了物理内存，但是这个程序有部分的内存可能并不是很常用，造成了内存的浪费。
>**为什么会内存交换效率低?** 因为硬盘的访问速度要慢的多，每一次内存交换，都需要把一大段连续的内存数据写到硬盘上。

### 内存分页
- **解决段式管理产生的外部内存碎片和内存交换的效率低的问题。**
- **分页式是把整个虚拟和物理内存切成一段段固定尺寸的大小。** 
- **虚拟地址与物理地址之间通过页表来映射。** 因为操作系统是可以同时运行非常多的内存的，所以页表会占用大量的内存。
  - 把虚拟内存地址，切分成页号和偏移量；
  - 根据页号，从页表里查询对应的物理页号。
  - 直接拿物理页号，加上前面的偏移量，就得到了物理内存地址。
- 简单分页的缺点
  - 操作系统可以同时运行非常多的进程的，这样就意味着页表会非常的庞大。
  - 解决方法就是多级页表。

>分页是如何解决分段的内存碎片，内存交换率低的问题？
>采用分页时释放的内存都是以页为单位释放的，就不会产生无法给进程使用的小内存。
>如果内存不够，操作系统会把其他正在运行的进程中的最近没被使用的内存页面给释放掉，也就是暂时写在硬盘上。一旦需要的时候，再加载进来，所以一次性写入磁盘的也只有少数的一页或者几页，不会花太多时间，**内存交换的效率相对就比较高。**

#### 多级页表

> 一个例子
>
> 对于单页表的实现，在32位(4GB虚拟内存)和页大小为4kB环境下，一个进程需要2^20个页，每个页表项需要4个字节，那么映射整个4GB空间就需要有4MB的内存来存储页表。如果多个进程的话，会更多。
>
> 对于二级页表（2^20个），可以分为1024个一级页表，每个一级页表包含1024个页表项，形成二级页表，这样一级页表就可以覆盖整个4GB虚拟内存，二级页表是使用到了再创建。
>
> 单页表为什么不能使用时再创建？
>
> 页表承担的职责是将虚拟地址映射为物理地址，假如虚拟地址在页表中找不到对应的页表项，计算机系统就不能工作了。

- **解决简单分页带来的占用内存大的问题**。主要体现为两个方面：二级页表可以不存在,二级页表可以不存在主存，存在磁盘中。
- **空间换时间**。解决了内存问题，但是带来了时间上的开销。


#### 快表(TLB)
- 解决虚拟地址到物理地址的转换太慢的问题。
- 将最常访问的几个页表项存储到访问速度更快的硬件，也就是专门存放程序最常访问的页表项的Cache，这个Cache就是TLB，在CPU寻址时，会先查快表。如果没有找到，才继续查常规的页表。


### 段页式内存管理
- 先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制；
- 接着将每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页。
- 段页式地址变换中要得到物理地址必须经过三次内存访问。
  - 第一次访问段表，得到页起始地址。
  - 第二次访问页表，得到物理页号。
  - 第三次将物理页号和页内位移组合，得到物理地址。

### 分页机制和分段机制的共同点和区别

1. **共同点**：
- **分页机制和分段机制都是为了提高内存的利用率，减少内存碎片。**
- **都是离散分配内存的方式。** 页和段都是离散存储的，但是每个页和段中的内存都是连续的。
2. **区别**：
- **页的大小是固定的**，由操作系统决定；**段的大小不固定**，取决于当前的程序。

# 调度算法

## 进程调度算法

- 先来先服务调度算法：顾名思义，先来后到，每次从就绪队列选择最先进⼊队列的进程，然后⼀直运⾏，直到进程退出或被阻塞，才会继续从队列中选择第⼀个进程接着运⾏。
- 最短作业优先调度算法：它会优先选择运⾏时间最短的进 程来运⾏，这有助于提⾼系统的吞吐量。
- ⾼响应⽐优先调度算法 ：每次进⾏进程调度时，先计算「响应⽐优先级」，然后把「响应⽐优先级」最⾼的进程投⼊运⾏，「响应 ⽐优先级」的计算公式：（等待时间+要求服务时间）/ 要求服务时间。主要是权衡了长作业和短作业。
- 时间⽚轮转调度算法：每个进程被分配⼀个时间段，称为时间⽚（Quantum），即允许该进程在该时间段中运⾏。通常时间⽚设为 20ms~50ms 通常是⼀个⽐较合理的折中值。
-  最⾼优先级调度算法：调度程序从就绪队列中选择最⾼优先级的进程进⾏运⾏。优先级分为静态优先级和动态优先级。
  - 静态优先级：创建进程时候，就已经确定了优先级了，然后整个运⾏时间优先级都不会变化；
  - 动态优先级：根据进程的动态变化调整优先级，⽐如如果进程运⾏时间增加，则降低其优先级，如果进程等待时间（就绪队列的等待时间）增加，则升⾼其优先级，也就是随着时间的推移增加等待进程的优先级。
- 多级反馈队列调度算法：「多级」表示有多个队列，每个队列优先级从⾼到低，同时优先级越⾼时间⽚越短。「反馈」表示如果有新的进程加⼊优先级⾼的队列时，⽴刻停⽌当前正在运⾏的进程，转⽽去运⾏优 先级⾼的队列；

## 内存页面置换算法

当CPU访问的页面不在物理内存时，便会产生一个缺页中断，请求操作系统将所缺页从磁盘调入到物理内存中，但是在换入之前，需要在物理内存中找空闲页，如果找到空闲页，就把页面换入到物理内存中。但是如果找不到，就需要选择一个物理页面换出到磁盘中，然后再将需要访问的页面换入到物理页。

- 最佳⻚⾯置换算法（OPT）：置换在未来最长时间不访问的页面。这种系统无法实现，所以，最佳⻚⾯置换算法作⽤是为了衡量置换算法的效率，算法效率越接近该算法的效率，那么说明算法是⾼效的。

- 先进先出置换算法（FIFO）：选择在内存驻留很长的页面进行置换。

- 最近最久未使⽤的置换算法（LRU）：选择最长时间没有访问的页面进行置换。

- 时钟⻚⾯置换算法（Lock）：当一个页面被装入内存时，把该位初始化为0，然后如果这个页面被访问（读/写），则把该位置为1；
  把各个页面组织成环形链表（类似于钟表面），把指针指向最老的页面（最先进来）；当发生一个缺页中断时，考察指针所指向的最老页面，若它的访问位为0，立即淘汰；若访问位为1，则把该位置为0，然后指针往下移动一格，如此下去，直至找到被淘汰的页面，然后把指针移动到它的下一格。

- 最不常⽤置换算法（LFU）：选择访问次数最少的页面进行置换。

  > 虽然 LRU 在理论上是可以实现的，但代价很⾼。为了完全实现 LRU，需要在内存中维护⼀个所有⻚⾯的 链表，最近最多使⽤的⻚⾯在表头，最近最少使⽤的⻚⾯在表尾。
  > 困难的是，在每次访问内存时都必须要更新「整个链表」。在链表中找到⼀个⻚⾯，删除它，然后把它移 动到表头是⼀个⾮常费时的操作。
  > 所以，LRU 虽然看上去不错，但是由于开销⽐较⼤，实际应⽤中⽐较少使⽤。
  >
  > LFU 算法只考虑了频率问题，没考虑时间的问题，⽐如有些⻚⾯在过去时间⾥访问的频率 很⾼，但是现在已经没有访问了，⽽当前频繁访问的⻚⾯由于没有这些⻚⾯访问的次数⾼，在发⽣缺⻚中断时，就会可能会误伤当前刚开始频繁访问，但访问次数还不⾼的⻚⾯。
  >
  > 那这个问题的解决的办法还是有的，可以定期减少访问的次数，⽐如当发⽣时间中断时，把过去时间访问 的⻚⾯的访问次数除以 2，也就说，随着时间的流失，以前的⾼访问次数的⻚⾯会慢慢减少，相当于加⼤了被置换的概率。

## 磁盘调度算法

磁盘调度算法的⽬的很简单，就是为了提⾼磁盘的访问性能，⼀般是通过优化磁盘的访问请求顺序来做到的。寻道的时间是磁盘访问最耗时的部分，如果请求顺序优化的得当，必然可以节省⼀些不必要的寻道时间， 从⽽提⾼磁盘的访问性能。

- 先来先服务算法 ：先来先服务（First-Come，First-Served，FCFS），顾名思义，先到来的请求，先被服务。当请求访问的磁道很分散时，性能就会很差，因为寻道的时间过长。
- 最短寻道时间优先算法 ：优先选择从当前磁头位置所需寻道时间最短的请求。有可能产生饥饿现象，因为磁头会有可能在一块区域来回移动。
- 扫描算法算法：磁头在⼀个⽅向上移动，访问所有未完成的请求，直到磁头到达该⽅向上 的最后的磁道，才调换⽅向，这就是扫描（Scan）算法。不会产生饥饿现象，但是中间的部分磁道会比较占便宜，因为中间部分相比于其他部分响应的频率会比较多。
- 循环扫描算法：只有磁头朝某个特定⽅向移动时，才处理磁道访问请求，⽽返 回时直接快速移动⾄最靠边缘的磁道，也就是复位磁头，这个过程是很快的，并且返回中途不处理任何请求，该算法的特点，就是磁道只响应⼀个⽅向上的请求。
- LOOK 与 C-LOOK 算法：扫描算法和循环扫描算法，都是磁头移动到磁盘「最始端或最末端」才开始调换⽅向。那这其实是可以优化的，优化的思路就是磁头在移动到「最远的请求」位置，然后⽴即反向移动。
  - 那针对 SCAN 算法的优化则叫 LOOK 算法，它的⼯作⽅式，磁头在每个⽅向上仅仅移动到最远的请求位 置，然后⽴即反向移动，⽽不需要移动到磁盘的最始端或最末端，反向移动的途中会响应请求。
  - ⽽针 C-SCAN 算法的优化则叫 C-LOOK，它的⼯作⽅式，磁头在每个⽅向上仅仅移动到最远的请求位置， 然后⽴即反向移动，⽽不需要移动到磁盘的最始端或最末端，反向移动的途中不会响应请求。

# Linux常用指令

## 目录切换命令

- **`cd usr`：** 切换到该目录下 usr 目录
- **`cd ..（或cd../）`：** 切换到上一层目录
- **`cd /`：** 切换到系统根目录
- **`cd ~`：** 切换到用户主目录
- **`cd -`：** 切换到上一个操作所在目录

## 目录的操作命令(增删改查)

- **`mkdir 目录名称`：** 增加目录。
- **`ls/ll`**（ll 是 ls -l 的别名，ll 命令可以看到该目录下的所有目录和文件的详细信息）：查看目录信息。
- **`find 目录 参数`：** 寻找目录（查）。示例：① 列出当前目录及子目录下所有文件和文件夹: `find .`；② 在`/home`目录下查找以.txt 结尾的文件名:`find /home -name "*.txt"` ,忽略大小写: `find /home -iname "*.txt"` ；③ 当前目录及子目录下查找所有以.txt 和.pdf 结尾的文件:`find . \( -name "*.txt" -o -name "*.pdf" \)`或`find . -name "*.txt" -o -name "*.pdf"`。
- **`mv 目录名称 新目录名称`：** 修改目录的名称（改）。注意：mv 的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行 重命名的操作。mv 命令用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中。后面会介绍到 mv 命令的另一个用法。
- **`mv 目录名称 目录的新位置`：** 移动目录的位置---剪切（改）。注意：mv 语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作。另外 mv 与 cp 的结果不同，mv 好像文件“搬家”，文件个数并未增加。而 cp 对文件进行复制，文件个数增加了。
- **`cp -r 目录名称 目录拷贝的目标位置`：** 拷贝目录（改），-r 代表递归拷贝 。注意：cp 命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不 用写-r 递归。
- **`rm [-rf] 目录` :** 删除目录（删）。注意：rm 不仅可以删除目录，也可以删除其他文件或压缩包，为了增强大家的记忆， 无论删除任何目录或文件，都直接使用`rm -rf` 目录/文件/压缩包。

### 文件的操作命令(增删改查)

- **`touch 文件名称`:** 文件的创建（增）。
- **`cat/more/less/tail 文件名称`** ：文件的查看（查） 。命令 `tail -f 文件` 可以对某个文件进行动态监控，例如 tomcat 的日志文件， 会随着程序的运行，日志会变化，可以使用 `tail -f catalina-2016-11-11.log` 监控 文 件的变化 。
- **`vim 文件`：** 修改文件的内容（改）。vim 编辑器是 Linux 中的强大组件，是 vi 编辑器的加强版，vim 编辑器的命令和快捷方式有很多，但此处不一一阐述，大家也无需研究的很透彻，使用 vim 编辑修改文件的方式基本会使用就可以了。在实际开发中，使用 vim 编辑器主要作用就是修改配置文件，下面是一般步骤： `vim 文件------>进入文件----->命令模式------>按i进入编辑模式----->编辑文件 ------->按Esc进入底行模式----->输入：wq/q!` （输入 wq 代表写入内容并退出，即保存；输入 q!代表强制退出不保存）。
- **`rm -rf 文件`：** 删除文件（删）。

##  其他常用命令

- **`pwd`：** 显示当前所在位置

- `sudo + 其他命令`：以系统管理者的身份执行指令，也就是说，经由 sudo 所执行的指令就好像是 root 亲自执行。

- **`grep 要搜索的字符串 要搜索的文件 --color`：** 搜索命令，--color 代表高亮显示

- **`ps -ef`/`ps -aux`：** 这两个命令都是查看当前系统正在运行进程，两者的区别是展示格式不同。如果想要查看特定的进程可以使用这样的格式：**`ps aux|grep redis`** （查看包括 redis 字符串的进程），也可使用 `pgrep redis -a`。

  注意：如果直接用 ps（（Process Status））命令，会显示所有进程的状态，通常结合 grep 命令查看某进程的状态。

- **`kill -9 进程的pid`：** 杀死进程（-9 表示强制终止。）

  先用 ps 查找进程，然后用 kill 杀掉

- **网络通信命令：**

  - 查看当前系统的网卡信息：`ifconfig`
  - 查看与某台机器的连接情况：`ping`
  - 查看当前系统的端口使用：`netstat -an`

- **net-tools 和 iproute2 ：** `net-tools`起源于 BSD 的 TCP/IP 工具箱，后来成为老版本 LinuxLinux 中配置网络功能的工具。但自 2001 年起，Linux 社区已经对其停止维护。同时，一些 Linux 发行版比如 Arch Linux 和 CentOS/RHEL 7 则已经完全抛弃了 net-tools，只支持`iproute2`。linux ip 命令类似于 ifconfig，但功能更强大，旨在替代它。更多详情请阅读[如何在 Linux 中使用 IP 命令和示例](https://linoxide.com/linux-command/use-ip-command-linux)

- **`shutdown`：** `shutdown -h now`： 指定现在立即关机；`shutdown +5 "System will shutdown after 5 minutes"`：指定 5 分钟后关机，同时送出警告信息给登入用户。

- **`reboot`：** **`reboot`：** 重开机。**`reboot -w`：** 做个重开机的模拟（只有纪录并不会真的重开机）。









